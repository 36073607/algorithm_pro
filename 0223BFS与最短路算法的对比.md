# BFS与最短路算法的对比

这是一个非常经典且核心的算法问题。简单来说，**BFS（广度优先搜索）通常是最短路算法的一种特例**，而“最短路算法”（如 Dijkstra、Floyd、SPFA）是更通用的解法。

选择哪种算法，主要取决于**图的边权情况**和**图的结构特征**。

以下是详细的决策逻辑和对比：

---

### 一、 核心判断标准：边权

这是区分两者的最主要依据。

#### 1. 无权图（或者所有边权相等） -> **首选 BFS**
*   **场景**：迷宫最短路径、棋盘上马走日、社交网络中“几度好友”关系。
*   **原因**：在无权图中，每走一步距离+1。BFS 的“层层扩散”特性保证了**第一次访问到目标节点时，一定是最短路径**。
*   **优势**：时间复杂度低 $O(V+E)$，代码极其简单，不需要优先队列或复杂的数据结构。
*   **注意**：如果是**无权图且边权不为1但相等**（例如每步代价都是5），BFS依然适用，最后距离乘以权值即可。

#### 2. 边权非负且不相等 -> **首选 Dijkstra**
*   **场景**：地图导航（距离不同）、网络路由（延迟不同）。
*   **原因**：当边权不同时，BFS 的“层数”不再代表距离。例如，BFS 先走到节点 A（距离10），后走到节点 B（距离1），但 BFS 会认为 A 更近（因为它层数少或先被访问），这是错误的。Dijkstra 通过**贪心策略**和**优先队列**，保证每次取出的都是当前距离源点最近的点。
*   **优势**：能正确处理正权图的最短路，时间复杂度 $O(E \log V)$（优先队列实现）。

#### 3. 边权有负数 -> **Bellman-Ford 或 SPFA**
*   **场景**：股票交易（手续费为负收益）、包含“后退/回溯”机制的游戏。
*   **原因**：Dijkstra 的贪心策略在负权边面前会失效（一旦节点被标记为“已确定最短路”，Dijkstra 不再更新，但负权边可能让后续路径更短）。BFS 更无法处理。
*   **注意**：如果有负权环，需要特殊判断。

---

### 二、 进阶判断标准：状态空间与存储方式

有时候问题不仅仅是“图”的形式，需要根据状态空间的大小来决定。

#### 1. 隐式图搜索 -> **通常是 BFS**
*   **场景**：八数码问题、华容道、翻转矩阵、最少操作次数。
*   **特征**：题目没有直接给出节点和边，而是给出一个初始状态和目标状态，问“最少几步能变过去”。
*   **决策**：
    *   如果操作代价均等（如“一步”），这就是典型的无权最短路。
    *   状态空间通常很大，不能用邻接表存，需要用 Hash 表记录状态是否访问过。
    *   **解决方案**：**BFS**（如果求最少步数）或 **A* 算法**（如果带启发式搜索）。

#### 2. 多源最短路 -> **Floyd-Warshall**
*   **场景**：求任意两个点之间的最短距离。
*   **决策**：虽然可以对每个点跑一次 Dijkstra/BFS，但如果图比较稠密且节点数少（$N < 400$），直接上 Floyd 算法（$O(N^3)$）最省事。

---

### 三、 总结对照表

为了方便记忆，可以参考这张决策表：

| 图的特征                | 适用算法                | 时间复杂度                   | 典型例题场景               |
| :---------------------- | :---------------------- | :--------------------------- | :------------------------- |
| **无权图 / 边权相等**   | **BFS**                 | $O(V+E)$                     | 走迷宫、单词接龙、层序遍历 |
| **正权图（边权不等）**  | **Dijkstra**            | $O(E \log V)$                | 地图导航、带权最短路       |
| **负权图（无负环）**    | **Bellman-Ford / SPFA** | $O(VE)$ / 极端退化为 $O(VE)$ | 带负花费的最优路径         |
| **多源最短路（N较小）** | **Floyd**               | $O(N^3)$                     | 传递闭包、任意两点间距离   |
| **矩阵/棋盘(步数最少)** | **BFS**                 | $O(R \times C)$              | 马走日、逃离迷宫           |
| **矩阵(带权移动代价)**  | **Dijkstra (01-BFS)**   | $O(R \times C \log (RC))$    | 代价不同的地形移动         |

### 四、 一个特殊的交集：01 BFS

有一种特殊情况介于 BFS 和 Dijkstra 之间：
*   **边权只有 0 和 1**。
*   如果用普通 Dijkstra 是可以的，但有点“杀鸡用牛刀”。
*   如果用普通 BFS，因为权值有 0（不增加距离），普通队列无法保证顺序。
*   **解法**：使用**双端队列**。
    *   遇到权值为 1 的边，将新节点加入队尾。
    *   遇到权值为 0 的边，将新节点加入队头。
*   这样保证了队列头的距离始终 $\le$ 队尾，起到了优先队列的作用，但复杂度是线性的 $O(V+E)$，优于 Dijkstra。

### 总结

**什么时候用 BFS？**
当你求“最少操作次数”、“最少步数”，且每一步的代价完全相同时。

**什么时候用最短路？**
当你求“最小代价”、“最短距离”，且每一步的代价（边权）不固定、不相同时。

**一句话概括：**
BFS 是处理**无权图**最短路的利器；而最短路算法（Dijkstra 等）是处理**带权图**的通用解法。先看边权，再做决定。