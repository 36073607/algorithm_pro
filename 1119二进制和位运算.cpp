#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
using namespace std;
//浅谈二进制
// 一个bit就是一位，每个bit存储一个二进制码（0/1）。一个字节由8个比特组成
// 二进制的最高位表示符号的正负，0为正、1为负
//十进制转二进制（正数）
// 用十进制数a不断%2得到余数并存储，再用a/2作为新的十进制数再次%2并存储。直到十进制数为0，将存储的余数倒序输出即为转化的二进制数
//二进制转十进制
// 二进制数从右往左分别乘2的n次方(n表示第几位)

//正数怎么用二进制表达
// 用上述方法即可
//负数怎么用二进制表达
// 先计算其绝对值的二进制，再取反加一即可（或者先减一再取反）
// 公式证明： ~(s-1) = ~s + 1
//二进制为负数如何转化为十进制
// 依旧取反加一再 化为 十进制即可

//整数最小值的特殊性：最绝对值还是自己
//关于16进制：每4位二进制可以表示一个16进制
int a = 0b11;//二进制表示
int b = 0x7f;//十六进制表示


//位运算符
//	&  与		两个位都为1时，结果才为1
//	|  或		两个位都为0时，结果才为0（只要有一个为1，其值为1）
//	^  异或	    两个位相同为0，相异为1
//	~  取反	    0变1，1变0
//	<< 左移	    各二进位全部左移若干位，高位丢弃，低位补0
//	>> 右移	    各二进位全部右移若干位，高位补0或符号位补齐
//  >>>  见下面代码(java中有这个运算符，cpp中没有)

#include <bitset>
//方法1：使用标准库（推荐）
void printBinary_std(int num) 
{
	std::cout << std::bitset<sizeof(int) * 8>(num) << std::endl;
}
//方法2：
//本文件的实现是以int来举例的
//对于long等类型完全同理
//不过要注意，如果long类型的数字num,有64位
//num & (1 << 48),这种写法不对
//因为1是一个int类型，只有32位，所以(1 << 48) 早就溢出了，所以无意义
//应该写成： num & (1L << 48)
void printBinary(int num)
{
	for (int i = 31; i >= 0; i--)
	{
		cout << ((num & (1 << i)) == 0 ? "0" : "1");
	}
	cout << endl;

	//注意：
	//关键代码可以改成： cout << ((num & (1 << i)) != 0 ? "1" : "0");
	//但不可以写成：cout << ((num & (1 << i)) == 1 ? "1" : "0");
	//因为a如果第i位有1，那么(a & (1 << i)) 的结果是2的i次方，而不一定是1
	//比如： a = 0010011
	//a的第0位是1，第一位是1，第四位是1
	//(a & (1 << 4)) == 16（不是1），说明a的第4位是1状态
}

int main()
{
	int i = 0b0011010;
	printBinary(i);
	printBinary(i << 1);
	printBinary(i << 3);
	//对于非负数， >>和>>>效果一样
	printBinary(i >> 1);
	printBinary(i >> 2);
	cout << endl;
	//对于负数，>>和>>>效果不一样
	int j = 0b111100000000000000000000000;
	printBinary(j);
	printBinary(j >> 2);
	
	//对于非负数：
	//非负数 << i ,等同于乘以2的i次方
    //非负数 >> i ,等同于除以2的i次方
	//只有非负数符合这个特征，负数不要用
        
	return 0;
}

//注：
//位运算符 | 、& 连接的两侧一定都会计算
//而逻辑运算符 || 、&& 则具有穿透的特点


//为什么设计二进制
//保证只有一套加法运算逻辑-->>算的快
//所以才把负数的二进制搞得很别扭

//关于溢出：
//一定要确保自己的调用结果不会溢出，计算机不会给你做检查

